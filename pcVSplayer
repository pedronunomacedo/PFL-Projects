

% If player chooses option 1 (Place a stone of their color 
%                         AND a neutral stone on empty cells)
game_cycle3(BoardSize, Board, N, OptionMenu, OptionDifficulty) :-
    (OptionDifficulty == 1),
    (OptionMenu == 3),
    player(Player),
    getPlayerSymbol(Player, PlayerSymbol),
    

    (PlayerSymbol == 'o' ->
        write('Player '), write(PlayerSymbol), write(' : '), nl, nl,
        askForOption(Option), 
        (Option = 1),
        takeInput1(Column, Row, Board, BoardSize, PlayerSymbol), nl,  nl % stone of their color
        ;
        optionTwoBotPlay(Column, Row, Board, BoardSize, PlayerSymbol), nl, nl
    ),
    
    
    retract(board(Board)),
    createBoardNew(BoardSize, BoardSize, Column, Row, Board, BoardNew, PlayerSymbol), % Put the stone with our colour
    assert(board(BoardNew)),

    
    game_over(BoardNew, PlayerSymbol, BoardSize, GameOver), 
    (GameOver == 1 ->
        printAllBoard(BoardSize, BoardNew),
        nl
        ;
        (PlayerSymbol == 'o' ->
            takeInput1(ColumnNeutral, RowNeutral, BoardNew, BoardSize, 'n'), nl, nl % neutral stone
            ;
            optionTwoBotPlay(ColumnNeutral, RowNeutral, BoardNew, BoardSize, 'n'), nl, nl
        ),
        
        createBoardNew(BoardSize, BoardSize, ColumnNeutral, RowNeutral, BoardNew, FinalBoard, 'n'), % Put the neutral stone
        assert(board(FinalBoard)),
        cls,
        initialMenuDisplay,


        retract(player(Player)),
        NewPlayer is (mod(Player, 2) + 1),
        assert(player(NewPlayer)), 

        printAllBoard(BoardSize, FinalBoard), nl, 
        
        Next is N+1,

        game_cycle3(BoardSize, FinalBoard, Next, OptionMenu, OptionDifficulty)
    ).


% If player choose option 2 (Replace two neutral stones with stones of their color, 
%                         AND replace a different stone of their color on the board to neutral stone)
game_cycle3(BoardSize, Board, N, OptionMenu, OptionDifficulty) :- 
    (OptionDifficulty == 1),
    (OptionMenu == 3),
    player(Player),
    getPlayerSymbol(Player, PlayerSymbol),
    (Option = 2), 

    takeInput2(Column, Row, Board, BoardSize, 'n'),
    retract(board(Board)),
    createBoardNew(BoardSize, BoardSize, Column, Row, Board, BoardNew, PlayerSymbol), % 1st neutral stone -> 1st player stone
    assert(board(BoardNew)), nl, 
    printAllBoard(BoardSize, BoardNew), nl, % intermediate board

    

        takeInput2(Column2, Row2, BoardNew, BoardSize, 'n'),
        retract(board(BoardNew)),
        createBoardNew(BoardSize, BoardSize, Column2, Row2, BoardNew, IntBoardNew, PlayerSymbol), % 2nd neutral stone -> 2nd player stone
        assert(board(IntBoardNew)),
        printAllBoard(BoardSize, IntBoardNew), nl, % intermediate board

        
        takeInput2(Column3, Row3, IntBoardNew, BoardSize, PlayerSymbol),
        retract(board(IntBoardNew)),
        createBoardNew(BoardSize, BoardSize, Column3, Row3, IntBoardNew, FinalBoard, 'n'), % player stone -> neutral stone
        assert(board(FinalBoard)),
        cls, 
        initialMenuDisplay,
        printAllBoard(BoardSize, FinalBoard), nl, % final board    

        game_over(FinalBoard, PlayerSymbol, BoardSize, GameOver),

        (GameOver == 1 ->
            nl
            ;
            Next is N+1,
            retract(player(Player)),
            NewPlayer is (mod(Player, 2) + 1),
            assert(player(NewPlayer)),
            game_cycle3(BoardSize, FinalBoard, Next, OptionMenu, OptionDifficulty)
        ).



game_cycle3(BoardSize, Board, N, OptionMenu, OptionDifficulty) :- 
    false.